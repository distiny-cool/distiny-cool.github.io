---
layout:     post
title:      栈溢出基础浅记（3）
subtitle:   
date:       2023-10-07
author:     Kody Black
header-img: img/post-bg-normal.jpg
catalog: true
tags:
    - pwn
---

### 控制rdx的方法

从上一篇文章可以发现，鲜有类似`pop rdx;ret`这样的指令。

wiki中介绍了一个方法，就是会找到strcmp函数，在执行该函数时，rdx会被设置为要被比较的字符串的长度，所以可以通过找到strcmp函数，从而控制rdx。

### 关于[HCTF2016 的出题人失踪了](https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/brop/hctf2016-brop)的发现

本来想着先用常规的方法做这道题，看看会不会出问题结果发现最后在执行`payload = b'a' * 64 + b'deadbeef' + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)`时总是失败，总结原因应该时libc版本的问题。同时试了下wiki给出的rop，也不能成功运行。

通过泄露got地址，发现puts地址为0x570a7ff04a680e50，__libc_start_main地址为0x570a7ffa31a29dc0，两个综合发现结果只有`libc6_2.35-0ubuntu3.4_amd64`，但是使用该libc的地址，得到的system函数的位置也并不正确。证明确实是libc版本有问题。

之后，我想着直接编重新用我的gcc编译一下（gcc version 11.4.0），使用命令为`gcc -fno-stack-protector -no-pie main.c -o brop`，这时使用ROPgadget查看，结果如下：

```
❯ ROPgadget --binary brop --only 'pop|ret'
Gadgets information
============================================================
0x000000000040117d : pop rbp ; ret
0x000000000040101a : ret

Unique gadgets found: 2
```

基本上没有pop，ret了，然后使用ida pro逆向，发现确实已经没有了`__libc_csu_init`函数，询问GPT的结果如下：

> 根据GCC的更新历史，自GCC版本4.9以后，新版本的GCC已经引入了新的启动过程（startup process）和初始化过程（initialization process）。在新的初始化过程中，不再使用libc_csu_fini和libc_csu_init函数。
>
> 在旧版本的GCC中，libc_csu_fini和libc_csu_init函数是用于在程序启动和结束时执行一些初始化和清理工作的。libc_csu_fini用于清理由libc_csu_init函数初始化的全局变量和静态变量，而libc_csu_init函数则负责初始化这些变量。
>
> 然而，由于新版本的GCC引入了更高级的启动和初始化过程，这些过程已经被重新设计和重构。因此，不再需要使用libc_csu_fini和libc_csu_init函数来进行初始化和清理工作。
>
> 总结起来，最新版的GCC编译的文件不再包含libc_csu_fini和libc_csu_init函数。

### 关于Blind ROP

这里写一下思路

- 找到栈溢出长度（暴力枚举）
- 泄露canaries 参考[canary的各种姿势----pwn题解版 - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/4657)
- 待续 :dog:

不想写了，wiki里面的栈溢出例题不多，可以看别的了
