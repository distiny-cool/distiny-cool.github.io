---
layout:     post
title:      【论文阅读】Understanding Linux Malware
subtitle:   2018 IEEE Symposium on Security and Privacy
date:       2022-11-22
author:     Kody Black
header-img: img/post-bg-normal.jpg
catalog: true
tags:
    - 论文阅读
    - Linux
---

## 概述&介绍

> 这是篇综述性论文，出发点是希望能够系统性的描述、分析、理解Linux恶意软件。

作者设计了一个恶意软件分析系统（介绍了其实现），并通过该系统检测了10548个恶意样本，最后的分析结果包括：

1. 搜集和分析Linux样本面对的挑战 
   - 二进制代码的静态分析
   - 合适环境的配置
   - 不同权限下的运行分析
2.  针对Linux的攻击技术
   - 反分析技巧
   - 加壳
   - 多态性
   - 逃逸
   - 持久驻留
3.  恶意软件的常见行为
   - 在多种操作系统中运行的能力
   - 权限提升
   - UPX加壳
   - 和一些shell工具交互
   - 分析有无root权限的情况下执行同一样本时的恶意软件行为

## 挑战

#### 目标的多样性 Target Diversity

- Linux支持多种计算机体系架构

- 不同的加载器和动态链接库（除了glibc外，有的会使用uClibc、musl等）

- 操作系统：难以区分不同版本的Linux、FreeBSD、Android的二进制文件

  - ELF标头上包含“OS/ABI”字段原则上指定程序运行所需的操作系统，但实际上Linux和Android的ELF文件都指定了通用的System V
  - Linux内核会将“OS/ABI”为“FreeBSD”的文件当作是有效的Linux程序（但是实际上除非是FreeBSD编译的动态链接程序，否则Linux和FreeBSD的系统调用参数不匹配导致程序会奔溃。
  
  ——>导致难以编译Linux恶意软件数据集、难以正常运行

#### 静态链接 Static Linking

> 即所有的库依赖都包含在二进制文件中

逆向分析更加困难，还有上面提到的不同内核差异导致运行奔溃

#### Analysis Environment

重点是说Linux的恶意代码很多会以root权限运行（尤其时嵌入式设备），这样的话这些恶意代码甚至可以篡改运行它的沙箱，让程序行为的检测和观察更加复杂

#### 缺乏前人的研究

- 如何构建分析管道
- 缺乏全面的数据集等

## 分析用的基础设施

> 主要将作者构建的恶意软件分析工具集，他们使用了包括AVClass，IDA pro，redare2，Nucleus以及他们自己设计的工具。总体过程如下图：

![Overview of analysis pipeline](https://files.catbox.moe/zt9h6o.png)

#### 数据收集

- used the **VirusTotal intelligence API** to fetch the reports of every ELF file
- 每天下载200个候选样本——>尽量避免之前的问题，选出Linux文件
- 分类：140个取自超过五个AV阳性的样本；60个AV得分再1-5的样本。

#### 文件和元数据

首先是分析文件本身，作者实现了一个自定义ELF格式解析器（用于提取出ELF文件的字段信息）

- 过滤掉与我们分析无关的文件
- 标识异常的文件结构（会阻止现有的工具对其正确处理）
- 提取每个样本的AV标签，输入**AVClass**以后的恶意软件系列的规范化名称

> M. Sebastian, R. Rivera, P. Kotzias, and J. Caballero, “AVclass: A Tool for Massive Malware Labeling,” in RAID, 2016.

#### 静态分析

> 包含两步

1. 二进制逆向

   - IDA Pro提取一些代码量度，如函数的数量、大小、圈复杂度（cyclomatic complexity）等等
   - 计算了聚合度量（aggregated metrics），如the distribution of opcodes, or a rolling entropy of the different code and data sections. （不太懂这部分

2. 判断是否加壳

   将之前得到的ELF报文头部提取的信息和代码分析相结合，识别可能加过壳的程序

   if packed : unpacked ----> statically analyzed again

   如果无法静态脱壳，则在之后进行动态分析处理

#### 动态分析

> 有两种动态分析类型

- 在instrumented emulator中执行五分钟

  共五个沙盒

  - KVM沙盒（x86和x86-64）
  - QEMU沙盒（ARM 32位小端、MIPS 32位大端和PowerPC 32位）

  沙盒嵌套在外部的VM中，会根据架构分配样本

  使用**[SystemTap](https://sourceware.org/systemtap)**来实现内核探测（kprobes）和用户探测（uprobes），收集每个系统调用以及其参数和返回值，还有系统调用的指令指针，以及添加的搜集字符串和内存操作函数的附加信息。

  > 以上部分执行结束后会返回一个文件包含系统调用和用户空间函数的完整过程

  - —>解析：识别有用的反馈信息
    - 缺少的组件（库和加载器）
    - 是否需要测试其他用户权限（如果需要，会以root权限执行，并进行差异分析
    - 报告异常样本执行时的错误
  - 另外，还会监管样本使用时的网络流量情况

- 自定义加壳分析和脱壳尝试

  开发了一个基于**[Unicorn](https://github.com/unicorn-engine/unicorn)**的工具，该工具会模拟多个体系结构上的指令，可以在脱壳过程中导出UPX使用的有限系统调用集，进而实现大部分样本的自动脱壳。

## 	数据集

