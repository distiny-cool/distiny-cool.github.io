---
layout:     post
title:      【论文阅读】Understanding Linux Malware
subtitle:   2018 IEEE Symposium on Security and Privacy
date:       2022-11-22
author:     Kody Black
header-img: img/post-bg-normal.jpg
catalog: true
tags:
    - 论文阅读
    - Linux
---

## 概述&介绍

> 这是篇综述性论文，出发点是希望能够系统性的描述、分析、理解Linux恶意软件。

作者设计了一个恶意软件分析系统（介绍了其实现），并通过该系统检测了10548个恶意样本，最后的分析结果包括：

1. 搜集和分析Linux样本面对的挑战 
   - 二进制代码的静态分析
   - 合适环境的配置
   - 不同权限下的运行分析
2.  针对Linux的攻击技术
   - 反分析技巧
   - 加壳
   - 多态性
   - 逃逸
   - 持久驻留
3.  恶意软件的常见行为
   - 在多种操作系统中运行的能力
   - 权限提升
   - UPX加壳
   - 和一些shell工具交互
   - 分析有无root权限的情况下执行同一样本时的恶意软件行为

## 挑战

### 目标的多样性 Target Diversity

- Linux支持多种计算机体系架构

- 不同的加载器和动态链接库（除了glibc外，有的会使用uClibc、musl等）

- 操作系统：难以区分不同版本的Linux、FreeBSD、Android的二进制文件

  - ELF标头上包含“OS/ABI”字段原则上指定程序运行所需的操作系统，但实际上Linux和Android的ELF文件都指定了通用的System V
  - Linux内核会将“OS/ABI”为“FreeBSD”的文件当作是有效的Linux程序（但是实际上除非是FreeBSD编译的动态链接程序，否则Linux和FreeBSD的系统调用参数不匹配导致程序会奔溃。
  
  ——>导致难以编译Linux恶意软件数据集、难以正常运行

### 静态链接 Static Linking

> 即所有的库依赖都包含在二进制文件中

逆向分析更加困难，还有上面提到的不同内核差异导致运行奔溃

### Analysis Environment

重点是说Linux的恶意代码很多会以root权限运行（尤其时嵌入式设备），这样的话这些恶意代码甚至可以篡改运行它的沙箱，让程序行为的检测和观察更加复杂

### 缺乏前人的研究

- 如何构建分析管道
- 缺乏全面的数据集等

## 分析用的基础设施

> 主要将作者构建的恶意软件分析工具集，他们使用了包括AVClass，IDA pro，redare2，Nucleus以及他们自己设计的工具。总体过程如下图：

![Overview of analysis pipeline](https://files.catbox.moe/zt9h6o.png)

### 数据收集

- used the **VirusTotal intelligence API** to fetch the reports of every ELF file
- 每天下载200个候选样本——>尽量避免之前的问题，选出Linux文件
- 分类：140个取自超过五个AV阳性的样本；60个AV得分再1-5的样本。

### 文件和元数据

首先是分析文件本身，作者实现了一个自定义ELF格式解析器（用于提取出ELF文件的字段信息）

- 过滤掉与我们分析无关的文件
- 标识异常的文件结构（会阻止现有的工具对其正确处理）
- 提取每个样本的AV标签，输入**[AVClass](https://github.com/malicialab/avclass)**以后的恶意软件系列的规范化名称

> M. Sebastian, R. Rivera, P. Kotzias, and J. Caballero, “AVclass: A Tool for Massive Malware Labeling,” in RAID, 2016.

### 静态分析

> 包含两步

1. 二进制逆向

   - IDA Pro提取一些代码量度，如函数的数量、大小、圈复杂度（cyclomatic complexity）等等
   - 计算了聚合度量（aggregated metrics），如the distribution of opcodes, or a rolling entropy of the different code and data sections. （不太懂这部分

2. 判断是否加壳

   将之前得到的ELF报文头部提取的信息和代码分析相结合，识别可能加过壳的程序

   if packed : unpacked ----> statically analyzed again

   如果无法静态脱壳，则在之后进行动态分析处理

### 动态分析

> 有两种动态分析类型

- 在instrumented emulator中执行五分钟

  共五个沙盒

  - KVM沙盒（x86和x86-64）
  - QEMU沙盒（ARM 32位小端、MIPS 32位大端和PowerPC 32位）

  沙盒嵌套在外部的VM中，会根据架构分配样本

  使用**[SystemTap](https://sourceware.org/systemtap)**来实现内核探测（kprobes）和用户探测（uprobes），收集每个系统调用以及其参数和返回值，还有系统调用的指令指针，以及添加的搜集字符串和内存操作函数的附加信息。

  > 以上部分执行结束后会返回一个文件包含系统调用和用户空间函数的完整过程

  - —>解析：识别有用的反馈信息
    - 缺少的组件（库和加载器）
    - 是否需要测试其他用户权限（如果需要，会以root权限执行，并进行差异分析
    - 报告异常样本执行时的错误
  - 另外，还会监管样本使用时的网络流量情况

- 自定义加壳分析和脱壳尝试

  开发了一个基于**[Unicorn](https://github.com/unicorn-engine/unicorn)**的工具，该工具会模拟多个体系结构上的指令，可以在脱壳过程中导出UPX使用的有限系统调用集，进而实现大部分样本的从自动脱壳。

## 	数据集

> 10548个ELF文件，覆盖了十多种不同架构

主要还是用AVClass工具进行了家族分类（83%的样本可以有效分类到108个家族）

分析数据集可以得出：

- 僵尸网络（Botnets）在Linux恶意软件中占主要地位（样本的69%，覆盖了25个以上家族）
  - 可能原因1：缺乏保护的IoT设备很容易被攻击者获取（通过Shodan或者ZMap都可以很快的定位目标），用来做DDos的肉鸡。
  - 可能原因2：这些恶意软件家族中一部分源码是公开的，导致了大量变体

- 其他样本还包括：后门、勒索软件、挖矿木马、银行木马、提权工具、rootkit、蠕虫等等。

## Under The Hood（恶意代码使用的技战术分析）

### 篡改ELF头部

| 技术                                           | 样本数 | 占比  |
| ---------------------------------------------- | ------ | ----- |
| Segment header table pointing beyond file data | 1      | 0.01% |
| Overlapping ELF header/segment                 | 2      | 0.02% |
| Wrong string table index (e_shstrndx)          | 60     | 0.57% |
| Section header table pointing beyond file data | 178    | 1.69% |
| 总计                                           | 211    | 2.00% |

> 这211个被篡改ELF头部的文件，都可以用IDA Pro 7正常解析，而readelf、GDB、pyelftools效果都不佳

恶意软件经常会篡改ELF头部以欺骗分析工具，这里分成了两类：导致异常文件(但仍然符合ELF文件规范）的修改和产生无效文件（但是可以正确执行）的修改

- 异常ELF

  - 删掉了所有的ELF节信息
  - 报告有关可执行文件的错误信息（例如针对不同ABI的程序会在运行时崩溃）

- 无效ELF

  具有错误或者损坏的节信息的样本（2%）

### 持久性

> Persistence，即实现在受害主机中的长期驻留，一般在windows里面会通过修改注册表、系统服务之类的方法。而Linux恶意软件需要依赖不同的策略（实际上就是修改类型不同的文件），这里分成了四类

| Path                | w/o root | w/ root |
| ------------------- | -------- | ------- |
| /etc/rc.d/rc.local  | -        | 1393    |
| /etc/rc.conf        | -        | 1236    |
| /etc/init.d/        | -        | 210     |
| /etc/rcX.d/         | -        | 212     |
| /etc/rc.local       | -        | 11      |
| systemd service     | -        | 2       |
| ˜/.bashrc           | 19       | 8       |
| ˜/.bash_profile     | 18       | 8       |
| X desktop autostart | 3        | 1       |
| /etc/cron.hourly/   | -        | 70      |
| /etc/crontab        | -        | 70      |
| /etc/cron.daily/    | -        | 26      |
| crontab utility     | 6        | 6       |
| File replacement    | -        | 110     |
| File infection      | 5        | 26      |

总计有1644个样本使用了该技术，占比21.10%，对于一个样本通常会连续使用多种技术以实现持久化

1. 子系统初始化

   利用Linux init系统（需要root权限）：修改rc脚本；添加自己到etc/init.d里面，然后创建到保存运行级配置的目录的软链接。

2. 基于时间的执行

   利用corn，恶意代码会修改corn的配置文件，从而在固定的时间间隔执行。

   （如果不是root权限，也可以通过利用crontab程序来进行配置cron）

3. 文件感染和替换

   类似病毒感染某系系统工具，让其带动恶意代码执行

4. 用户文件更改

   如果没有root权限，恶意代码可能会修改用户目录的配置文件

